

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

CREATE EXTENSION IF NOT EXISTS "pg_cron" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pg_net" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pgsodium" WITH SCHEMA "pgsodium";

ALTER SCHEMA "public" OWNER TO "postgres";

CREATE EXTENSION IF NOT EXISTS "http" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";

CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pgjwt" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";

CREATE TYPE "public"."parcels_monitoring_subscription_carrier" AS (
	"tracking_id" character varying,
	"carrier_name" character varying,
	"carrier_id" integer,
	"user_id" "uuid",
	"last_updated" timestamp with time zone,
	"keys" "json",
	"endpoint" character varying,
	"expiration_time" timestamp with time zone
);

ALTER TYPE "public"."parcels_monitoring_subscription_carrier" OWNER TO "postgres";

CREATE FUNCTION "public"."get_data"() RETURNS TABLE("tracking_id" character varying, "carrier_name" character varying, "carrier_id" bigint, "user_id" "uuid", "last_updated" timestamp without time zone, "keys" "json", "endpoint" character varying)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
RETURN QUERY
SELECT parcels_monitoring.tracking_id, carriers.name as carrier_name, carriers.id as carrier_id, parcels_monitoring.user_id, parcels_monitoring.last_updated, subscriptions.keys, subscriptions.endpoint, subscriptions."expirationTime" FROM (
  (parcels_monitoring inner join subscriptions on parcels_monitoring.user_id = subscriptions.user_id)
  inner join carriers on parcels_monitoring.carrier_id = carriers.id);
END;
$$;

ALTER FUNCTION "public"."get_data"() OWNER TO "postgres";

CREATE FUNCTION "public"."get_parcels_monitoring"() RETURNS TABLE("tracking_id" character varying, "count_events" integer, "carrier" "json", "last_updated" timestamp with time zone, "subscriptions" "json")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY SELECT 
        pm.tracking_id::VARCHAR,
        pm.count_events::integer, 
        json_build_object('id', c.id, 'name', c.name) AS carrier,
        -- pm.user_id::UUID, 
        pm.last_updated::TIMESTAMP WITH TIME ZONE,
        json_agg(json_build_object('id', s.id, 'keys', s.keys, 'endpoint', s.endpoint, 'expirationTime', s."expirationTime")) AS subscriptions
    FROM parcels_monitoring pm
    INNER JOIN subscriptions s ON pm.user_id = s.user_id
    INNER JOIN carriers c ON pm.carrier_id = c.id
    WHERE pm.last_checked <= now() - interval '25 minutes'
    GROUP BY pm.id, c.id, c.name, pm.tracking_id;
END;
$$;

ALTER FUNCTION "public"."get_parcels_monitoring"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";

CREATE TABLE "public"."carriers" (
    "id" bigint NOT NULL,
    "name" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "active" boolean NOT NULL
);

ALTER TABLE "public"."carriers" OWNER TO "postgres";

ALTER TABLE "public"."carriers" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."carriers_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE "public"."parcels_monitoring" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "tracking_id" character varying NOT NULL,
    "carrier_id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "last_updated" timestamp with time zone DEFAULT "now"() NOT NULL,
    "statusId" bigint DEFAULT '99'::bigint NOT NULL,
    "count_events" bigint DEFAULT '0'::bigint NOT NULL,
    "last_checked" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE "public"."parcels_monitoring" OWNER TO "postgres";

ALTER TABLE "public"."parcels_monitoring" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."parcels_monitoring_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE "public"."subscriptions" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "endpoint" character varying,
    "keys" "json",
    "user_id" "uuid" NOT NULL,
    "expirationTime" timestamp without time zone
);

ALTER TABLE "public"."subscriptions" OWNER TO "postgres";

ALTER TABLE "public"."subscriptions" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."subscriptions_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

ALTER TABLE ONLY "public"."carriers"
    ADD CONSTRAINT "carriers_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."parcels_monitoring"
    ADD CONSTRAINT "parcels_monitoring_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."parcels_monitoring"
    ADD CONSTRAINT "parcels_monitoring_carrier_id_fkey" FOREIGN KEY ("carrier_id") REFERENCES "public"."carriers"("id");

ALTER TABLE ONLY "public"."parcels_monitoring"
    ADD CONSTRAINT "parcels_monitoring_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

CREATE POLICY "Enable delete for authenticated users based on user_id" ON "public"."parcels_monitoring" FOR DELETE TO "authenticated" USING (("auth"."uid"() = "user_id"));

CREATE POLICY "Enable delete for users based on user_id" ON "public"."subscriptions" FOR DELETE TO "authenticated" USING (("auth"."uid"() = "user_id"));

CREATE POLICY "Enable insert for authenticated users only" ON "public"."parcels_monitoring" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));

CREATE POLICY "Enable read access for all users" ON "public"."carriers" FOR SELECT USING (true);

CREATE POLICY "Enable read access for all users" ON "public"."subscriptions" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));

CREATE POLICY "Enable read access for authenticated users and based on user_id" ON "public"."parcels_monitoring" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));

ALTER TABLE "public"."carriers" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."parcels_monitoring" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."subscriptions" ENABLE ROW LEVEL SECURITY;

REVOKE USAGE ON SCHEMA "public" FROM PUBLIC;
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

GRANT ALL ON FUNCTION "public"."get_data"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_data"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_data"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_parcels_monitoring"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_parcels_monitoring"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_parcels_monitoring"() TO "service_role";

GRANT ALL ON TABLE "public"."carriers" TO "anon";
GRANT ALL ON TABLE "public"."carriers" TO "authenticated";
GRANT ALL ON TABLE "public"."carriers" TO "service_role";

GRANT ALL ON SEQUENCE "public"."carriers_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."carriers_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."carriers_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."parcels_monitoring" TO "anon";
GRANT ALL ON TABLE "public"."parcels_monitoring" TO "authenticated";
GRANT ALL ON TABLE "public"."parcels_monitoring" TO "service_role";

GRANT ALL ON SEQUENCE "public"."parcels_monitoring_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."parcels_monitoring_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."parcels_monitoring_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."subscriptions" TO "service_role";

GRANT ALL ON SEQUENCE "public"."subscriptions_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."subscriptions_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."subscriptions_id_seq" TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "service_role";

RESET ALL;
